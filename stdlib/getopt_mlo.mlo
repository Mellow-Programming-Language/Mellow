
import std.core;
import std.getopt;

variant ArgType {
    CharType (bool),
    StringType (bool),
    FlagType (bool),
    NumType (bool),
}

struct SplitRes {
    argnames: []string;
    argtype: ArgType;
}

func splitArg(arg: string): Maybe!SplitRes {
    argnames: []string;
    argname := "";
    postEq := false;
    foreach (i, c; arg) {
        if (c == '|') {
            if (argname == "" || postEq) {
                return None!SplitRes;
            }
            argnames = argnames ~ [argname];
            argname = "";
        }
        else if (c == '=') {
            postEq = true;
        }
        else if (!postEq) {
            argname = argname ~ c;
        }
        else {
            match (arg[i..]) {
                ['s', '*'] :: return Some!SplitRes (
                    SplitRes {
                        argnames = argnames,
                        argtype = StringType (true)
                    }
                );
                ['s'] :: return Some!SplitRes (
                    SplitRes {
                        argnames = argnames,
                        argtype = StringType (false)
                    }
                );
                ['c', '*'] :: return Some!SplitRes (
                    SplitRes {
                        argnames = argnames,
                        argtype = CharType (true)
                    }
                );
                ['c'] :: return Some!SplitRes (
                    SplitRes {
                        argnames = argnames,
                        argtype = CharType (false)
                    }
                );
                ['n', '*'] :: return Some!SplitRes (
                    SplitRes {
                        argnames = argnames,
                        argtype = NumType (true)
                    }
                );
                ['n'] :: return Some!SplitRes (
                    SplitRes {
                        argnames = argnames,
                        argtype = NumType (false)
                    }
                );
                ['*'] :: return Some!SplitRes (
                    SplitRes {
                        argnames = argnames,
                        argtype = FlagType (true)
                    }
                );
                [_, ..] :: return None!SplitRes;
            }
        }
    }
    return Some!SplitRes (
        SplitRes {
            argnames = argnames,
            argtype = FlagType (false)
        }
    );
}
// Each string in control can take permutations of the following forms:
//   "o"
//   "o|out"
//   "o=s"
//   "o=s*"
//   "o=n"
//   "o=*"
//   "o=c*"
//   "o|out|output=s"
// Each string before the optional '=', each optionally delimited by '|',
// represent the accepted names for a single argument. If there is no
// "=..." content, then the argument is a flag. If there is a "=..."
// component, then the acceptable keys thereafter are:
//   s - string
//   c - char
//   n - integer
// Such that getopt will mandate that the value actually passed on the
// commandline is of the specified type. The key can be optionally followed
// by a '*', indicating that that argument can be provided multiple times.
// As a special case, "...=*" means that that boolean flag can be provided
// multiple times.
//
// Any unrecognized arguments will be kept in the "rest" string array in the
// returned GetOptResult struct.
func getopt(controls: []string, argv: []string): Maybe!GetOptResult {
    parsedControls: []Maybe!(SplitRes);
    foreach (con: controls) {
        parsedControls = parsedControls ~ splitArg(con);
    }
    return None!GetOptResult;
}
